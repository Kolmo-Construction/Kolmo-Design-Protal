the state management for the editing process should be refactored. Instead of using multiple useState hooks for the ID, title, and description of the item being edited, it is better to use a single state object. This consolidates the editing state and prevents unintended side effects during re-renders.

Below are the recommended changes for the simple-before-after-manager (3).tsx file.

1. Refactor State Management
Replace the individual state variables for editing with a single state object.

Current Code:

TypeScript

// simple-before-after-manager (3).tsx
const [editingId, setEditingId] = useState<number | null>(null);
const [editingTitle, setEditingTitle] = useState("");
const [editingDescription, setEditingDescription] = useState("");
New Code:

TypeScript

// simple-before-after-manager (3).tsx
import type { QuoteBeforeAfterPair } from "@shared/schema";

// ... inside the component
const [editingPair, setEditingPair] = useState<QuoteBeforeAfterPair | null>(null);
2. Update Event Handlers
Modify the handleStartEdit, handleSaveEdit, and handleCancelEdit functions to use the new editingPair state object. This decouples the handlers from individual state variables and makes their dependencies cleaner.

New handleStartEdit:

TypeScript

// simple-before-after-manager (3).tsx
const handleStartEdit = useCallback((pair: QuoteBeforeAfterPair) => {
  setEditingPair(JSON.parse(JSON.stringify(pair))); // Create a deep copy to avoid direct state mutation
}, []);
New handleCancelEdit:

TypeScript

// simple-before-after-manager (3).tsx
const handleCancelEdit = useCallback(() => {
  setEditingPair(null);
}, []);
New handleSaveEdit:

TypeScript

// simple-before-after-manager (3).tsx
const handleSaveEdit = useCallback(() => {
  if (!editingPair) return;

  if (!editingPair.title || !editingPair.title.trim()) {
    toast({ title: "Error", description: "Please enter a title.", variant: "destructive" });
    return;
  }
  
  updatePairMutation.mutate({ 
    id: editingPair.id, 
    data: { 
      title: editingPair.title, 
      description: editingPair.description 
    } 
  }, {
    onSuccess: () => {
      setEditingPair(null); // Exit edit mode
    }
  });
}, [editingPair, updatePairMutation, toast]);
3. Update the JSX
Finally, update the JSX to use the new editingPair state for conditional rendering and data binding.

Current Code Snippets:

TypeScript

// simple-before-after-manager (3).tsx
{editingId === pair.id ? ( /* ... */ ) : ( /* ... */ )}

<Input
  value={editingTitle}
  onChange={(e) => setEditingTitle(e.target.value)}
  // ...
/>
<Textarea
  value={editingDescription}
  onChange={(e) => setEditingDescription(e.target.value)}
  // ...
/>

<Button onClick={() => handleSaveEdit(pair.id)}>
New Code Snippets:

TypeScript

// simple-before-after-manager (3).tsx
{editingPair?.id === pair.id ? (
  // Edit Form
  <div className="space-y-2">
    <Input
      value={editingPair.title || ""}
      onChange={(e) => setEditingPair(p => p ? { ...p, title: e.target.value } : null)}
      placeholder="Enter title..."
      className="text-base font-semibold"
    />
    <Textarea
      value={editingPair.description || ""}
      onChange={(e) => setEditingPair(p => p ? { ...p, description: e.target.value } : null)}
      placeholder="Enter description (optional)..."
      rows={2}
      className="text-sm"
    />
  </div>
) : (
  // Display view
  <div>
    <CardTitle className="text-base">{pair.title}</CardTitle>
    {pair.description && (
      <p className="text-sm text-muted-foreground mt-1">{pair.description}</p>
    )}
  </div>
)}

// ... update buttons
{editingPair?.id === pair.id ? (
  <>
    <Button
      size="sm"
      onClick={handleSaveEdit}
      disabled={updatePairMutation.isPending || !editingPair?.title?.trim()}
    >
      <Save className="h-4 w-4 mr-1" />
      {updatePairMutation.isPending ? "Saving..." : "Save"}
    </Button>
    <Button
      size="sm"
      variant="outline"
      onClick={handleCancelEdit}
      disabled={updatePairMutation.isPending}
    >
      Cancel
    </Button>
  </>
) : (
  // ... Edit and Delete buttons
)}
By implementing these changes, you will resolve the bug by creating a more predictable and stable state management flow for the editing functionality. The form will correctly wait for you to make changes and click the "Save" button before taking any action.