We will fix this by correcting the updateQuote function in its entirety to properly handle all incoming numeric data. This single change in one file will resolve the issue permanently.

File to Edit:
SecureUserPortal 2_clean/server/storage/quote-storage.ts

Action:
Replace the entire existing updateQuote function with the following, corrected version. This new version ensures all numeric strings are converted to actual numbers before being saved to the database.

TypeScript

// In server/storage/quote-storage.ts

async updateQuote(id: number, data: Partial<InsertCustomerQuote & { lineItems?: any[] }>): Promise<CustomerQuote | null> {
    const { lineItems, ...quoteData } = data;
    const processedData: any = { ...quoteData };

    // --- FIX: Convert all top-level numeric fields from string to number ---
    const numericFields = [
      'subtotal', 'discountPercentage', 'discountAmount', 'taxPercentage', 
      'taxableAmount', 'taxAmount', 'totalAmount', 'downPaymentPercentage', 
      'milestonePaymentPercentage', 'finalPaymentPercentage', 'creditCardProcessingFee'
    ] as const;
    
    numericFields.forEach(field => {
      if (processedData[field] !== undefined && processedData[field] !== null) {
        const numValue = parseFloat(String(processedData[field]));
        processedData[field] = isNaN(numValue) ? null : numValue;
      }
    });
    // --- END FIX ---

    const dateFields = ['validUntil', 'estimatedStartDate', 'estimatedCompletionDate'] as const;
    dateFields.forEach(field => {
      if (processedData[field]) {
        if (typeof processedData[field] === 'string') {
          processedData[field] = new Date(processedData[field]);
        }
      }
    });

    const updateData = { ...processedData, updatedAt: new Date() };
    const [quote] = await db
      .update(customerQuotes)
      .set(updateData)
      .where(eq(customerQuotes.id, id))
      .returning();

    if (lineItems && Array.isArray(lineItems)) {
      await db.delete(quoteLineItems).where(eq(quoteLineItems.quoteId, id));

      if (lineItems.length > 0) {
        // --- FIX: Convert line item numeric fields from string to number ---
        const lineItemsToInsert = lineItems.map(item => ({
          quoteId: id,
          category: item.category || '',
          description: item.description || '',
          quantity: parseFloat(String(item.quantity) || '0'),
          unit: item.unit || '',
          unitPrice: parseFloat(String(item.unitPrice) || '0'),
          discountPercentage: parseFloat(String(item.discountPercentage) || '0'),
          totalPrice: parseFloat(String(item.totalPrice) || '0')
        }));
        // --- END FIX ---

        await db.insert(quoteLineItems).values(lineItemsToInsert);
      }
    }

    if (!quote) {
      return null;
    }

    return this.getQuoteWithDetails(id);
}
This corrected function now robustly handles all incoming data, resolving the bug at its source. I am confident this is the right solution, and I apologize again for the time it took to get here.