 Let's break it down:

[apiRequest] POST /api/login - Your credentials are sent correctly.
[apiRequest] Response: {id: 1, ...} - The server authenticates you and successfully sends back your user data.
[LoginMutation] onSuccess called with userData: - The useMutation hook successfully receives the user data.
[LoginMutation] User data set in cache - The queryClient.setQueryData line runs, updating React Query's internal cache with the new user object.
The process stops right there. The final, critical step—where React re-renders the page because the user object has changed—is not happening. The useEffect in your auth-page that should redirect you is never triggered because it never receives the updated user state.

While manually setting the query data should work, there is a more robust and standard pattern in React Query for this exact scenario: query invalidation.

Instead of manually pushing the login data into the cache, we will simply tell React Query: "The user data we have is now stale. Go fetch the latest version." Since the login was successful and the browser now has the session cookie, the new request to /api/user will succeed and reliably trigger all necessary UI updates.

The Definitive Solution
This change should resolve the login redirect issue.

File to Edit: client/src/hooks/use-auth.txt

1. Locate the loginMutation: Find the useMutation hook responsible for logging in.

2. Replace the onSuccess handler:

Change this:

TypeScript

// client/src/hooks/use-auth.txt
// ...
    onSuccess: (userData) => {
      console.log('[LoginMutation] onSuccess called with userData:', userData);
      
      // Manually updates the cache but isn't triggering a re-render
      queryClient.setQueryData(["/api/user"], userData);
      console.log('[LoginMutation] User data set in cache');
    },
// ...
To this more robust version:

TypeScript

// client/src/hooks/use-auth.txt
// ...
    onSuccess: () => {
      console.log('[LoginMutation] onSuccess: Invalidating user query to trigger refetch.');
      
      // Invalidate the user query. This tells any component using this query
      // (like our useAuth hook) that its data is stale and needs to be refetched.
      // React Query will automatically make a new GET /api/user request.
      queryClient.invalidateQueries({ queryKey: ["/api/user"] });
    },
// ...
Why This Works
You click "Sign In".
The loginMutation sends a POST to /api/login.
The server authenticates you and sets a session cookie in your browser.
The onSuccess handler now fires and calls invalidateQueries.
The useQuery for ["/api/user"] inside your useAuth hook is now marked as stale and immediately re-fetches.
The new GET request to /api/user is sent with the session cookie, so the server responds with your user data.
The useAuth hook now has a valid user object, which triggers a re-render in AuthPage.
The useEffect in AuthPage sees the new user object and finally redirects you to the dashboard.
This process is more resilient and leverages React Query's core strength, ensuring the client state is always synchronized with the server's state after a mutation.