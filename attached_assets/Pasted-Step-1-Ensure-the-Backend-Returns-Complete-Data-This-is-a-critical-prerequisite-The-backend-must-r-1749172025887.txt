Step 1: Ensure the Backend Returns Complete Data
This is a critical prerequisite. The backend must return the full, updated quote object after a change is made. My previous analysis of the data type mismatch was also correct and needs to be implemented alongside this new fix for the caching.

File to Edit: SecureUserPortal 2_clean/server/storage/quote-storage.ts

Action: In the updateQuote function, you must ensure that a) the line item values are converted to numbers, and b) the function returns the entire updated quote with all its details.

Replace the updateQuote function with this corrected version:

TypeScript

// In server/storage/quote-storage.ts

async updateQuote(id: number, data: Partial<InsertCustomerQuote & { lineItems?: any[] }>): Promise<CustomerQuote | null> {
    const { lineItems, ...quoteData } = data;

    const processedData: any = { ...quoteData };
    
    // Handle date fields specifically
    const dateFields = ['validUntil', 'estimatedStartDate', 'estimatedCompletionDate'] as const;
    dateFields.forEach(field => {
      if (processedData[field] && typeof processedData[field] === 'string') {
        processedData[field] = new Date(processedData[field]);
      }
    });

    const numericFields = [
      'subtotal', 'discountPercentage', 'discountAmount', 'taxPercentage', 
      'taxableAmount', 'taxAmount', 'totalAmount', 'downPaymentPercentage', 
      'milestonePaymentPercentage', 'finalPaymentPercentage', 'creditCardProcessingFee'
    ] as const;
    
    numericFields.forEach(field => {
      if (processedData[field] === '' || processedData[field] === undefined || processedData[field] === null) {
        delete processedData[field];
      }
    });

    const updateData = { ...processedData, updatedAt: new Date() };
    const [quote] = await db
      .update(customerQuotes)
      .set(updateData)
      .where(eq(customerQuotes.id, id))
      .returning();

    if (lineItems && Array.isArray(lineItems)) {
      await db
        .delete(quoteLineItems)
        .where(eq(quoteLineItems.quoteId, id));

      if (lineItems.length > 0) {
        // FIX: Convert string values to numbers before inserting
        const lineItemsToInsert = lineItems.map(item => ({
          quoteId: id,
          category: item.category || '',
          description: item.description || '',
          quantity: parseFloat(String(item.quantity)) || 0,
          unit: item.unit || '',
          unitPrice: parseFloat(String(item.unitPrice)) || 0,
          discountPercentage: parseFloat(String(item.discountPercentage)) || 0,
          totalPrice: parseFloat(String(item.totalPrice)) || 0
        }));
        await db.insert(quoteLineItems).values(lineItemsToInsert);
      }
    }

    if (!quote) {
      return null;
    }

    // FIX: Fetch and return the complete quote with all its details
    return this.getQuoteWithDetails(id);
}
Step 2: Manually Update the Frontend Cache
Now, we will instruct the frontend to take the complete data from the server's response and use it to update the cache directly. This is a more robust pattern than just invalidating the query.

File to Edit: SecureUserPortal 2_clean/client/src/components/quotes/edit-quote-dialog.txt

Action: Modify the onSuccess handler within the updateQuoteMutation to manually set the query data.

Replace the updateQuoteMutation with this corrected version:

TypeScript

// In client/src/components/quotes/edit-quote-dialog.tsx

const updateQuoteMutation = useMutation({
    mutationFn: async (data: QuoteFormData) => {
      const payload = {
        ...data,
        subtotal: calculatedTotals.subtotal.toFixed(2),
        discountAmount: calculatedTotals.discountAmount.toFixed(2),
        taxableAmount: calculatedTotals.taxableAmount.toFixed(2),
        taxAmount: calculatedTotals.taxAmount.toFixed(2),
        totalAmount: calculatedTotals.totalAmount.toFixed(2),
        lineItems: data.lineItems.map(item => ({
          ...item,
          totalPrice: calculateLineItemTotal(item.quantity, item.unitPrice, item.discountPercentage).toFixed(2),
        })),
        estimatedStartDate: data.estimatedStartDate ? new Date(data.estimatedStartDate) : undefined,
        estimatedCompletionDate: data.estimatedCompletionDate ? new Date(data.estimatedCompletionDate) : undefined,
        validUntil: data.validUntil ? new Date(data.validUntil) : undefined,
      };
      
      // The type from the backend will be a full CustomerQuote with details
      return await apiRequest("PUT", `/api/quotes/${quote?.id}`, payload) as unknown as (CustomerQuote & { lineItems: any[] });
    },
    onSuccess: (updatedQuote) => {
      // FIX: Manually update the cache with the fresh data from the server
      queryClient.setQueryData(['/api/quotes'], (oldData: CustomerQuote[] | undefined) => {
        if (!oldData) return [updatedQuote];
        return oldData.map(q => q.id === updatedQuote.id ? updatedQuote : q);
      });

      toast({
        title: "Success",
        description: "Quote updated successfully",
      });
      onOpenChange(false);
      onSuccess?.();
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: "Failed to update quote",
        variant: "destructive",
      });
    },
});
These two changes, working together, create a reliable data-saving-and-refreshing pipeline that will correctly persist your line item edits and immediately reflect them in the user interface.